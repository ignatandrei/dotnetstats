@page "/"
@using Microsoft.AspNetCore.Components.WebAssembly.Hosting
@using StatsInterfaces
@using System.Text.Json


<PageTitle>Home</PageTitle>

@* <h1>Hello, world @hostEnvironment?.BaseAddress </h1>

<h1>@httpApi?.BaseAddress</h1>
 *@
<DisplayProjects data="@projects?.ToArray()" ></DisplayProjects>
@* <button class="btn btn-primary" @onclick="StreamProjectsJson">Stream Projects</button> *@


@code{
    private bool isFirstRender = true;
    [Inject(Key = "statsconsole_host")]
    public HttpClient? httpApi { get; set; }
    [Inject]
    public IWebAssemblyHostEnvironment? hostEnvironment { get; set; }

    public List<Project_null>? projects = null;
    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (isFirstRender)
        {
            isFirstRender = false;
            await StreamProjectsJson();
        }
    }



    private async Task StreamProjectsJson()
    {
        ArgumentNullException.ThrowIfNull(httpApi);
        projects = new List<Project_null>();

        StateHasChanged();
        //TODO: change the url to have in both api and here , not hardcoded
        HttpRequestMessage request = new HttpRequestMessage(HttpMethod.Get, "api/StandAlone_DotNetFoundation/ObtainData/projects/all");
        request.SetBrowserResponseStreamingEnabled(true);


        using HttpResponseMessage response = await httpApi.SendAsync(request, HttpCompletionOption.ResponseHeadersRead);

        response.EnsureSuccessStatusCode();

        using Stream responseStream = await response.Content.ReadAsStreamAsync();

        await foreach (Project_null? prj in JsonSerializer.DeserializeAsyncEnumerable<Project_null>(
            responseStream,
            new JsonSerializerOptions
                {
                    PropertyNameCaseInsensitive = true,
                    DefaultBufferSize = 128
                }))
        {
            if (prj == null) continue;

            projects.Add(prj);
            if (projects.Count % 10 == 0){
                StateHasChanged();
                await Task.Delay(1000);
            }
        }
        StateHasChanged();
    }

}